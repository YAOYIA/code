# 哨兵线程
也常被称为守护线程或标记线程，它本身不执行核心的业务逻辑，而是扮演一个监视者或协调者的角色。它的主要任务是监视系统的状态（比如工作队列是否为空、其他工作线程是否存活），并根据这些状态来协调或通知其他线程的开始、暂停或结束。
简单来说，她像是一个生产线上巡逻的建工，自己不参与生产，但是时刻关注着原料是否充足、工人是否正常工作。

## 主要的作用和常见场景
哨兵线程最典型的应用场景是线程池或者生产者-消费者模型，用于优雅地关闭工作线程。

## 场景示例
一个简单的线程池
1.一个任务队列（blockingQueue）:存放待处理的任务
2.多个工作线程（worker thread）:不断冲队列中取出任务并执行
3.一个哨兵线程（sentinel thread）：负责整理整个池子的声明周期

正常工作时：
工作线程不断循环，从任务队列中取任务
如果队列为空，工作线程会阻塞等待，直到有新任务到来。

当需要关闭线程池的时候，问题来了：
如果强制中断工作的线程，队列中可能还会有未完成的任务，这会导致数据丢失或不一致，我们需要一种优雅的关闭方式，让所有的自己提交的任务都执行完毕之后在关闭线程
这个时候，哨兵线程就排上用场了。
优雅关闭流程：
1.发出停止的信号：用户调用threadPool.shutdown()方法。这个方法并不会直接中断线程，而是由哨兵线程将线程池的状态标记为“停止接受新任务”。
2.插入“毒丸”：哨兵线程向任务队列中放入一个或者多个特殊的、被称为“毒丸”的任务，这个任务就是一个预定义的、独一无二的对象
3.工作线程发现“毒丸”：工作线程和往常一样从队列中去任务。当某个工作线程取到这个“毒丸”任务的时候，他就明白这是一个停止信号
4.工作线程自行退出：工作线程在收到“毒丸”后，不会执行正常业务逻辑，而是会跳出它的主循环，并自然地结束运行
5.哨兵线程等待所有线程结束：哨兵线程会调用thread.join等方法，等待所有工作线程都安全退出。
6。资源清理：确认所有的工作线程结束

# 关键要点总结
非核心角色：它不处理业务，只为管理而存在。
协调与控制：通过监视共享状态（如队列、标志位）或发送特殊信号（如“毒丸”）来控制其他线程的行为。
实现优雅停机：这是它最重要的用途之一，避免了强制中断带来的资源泄漏或数据问题。
“毒丸”模式：是哨兵线程实现其功能的一种经典设计模式。